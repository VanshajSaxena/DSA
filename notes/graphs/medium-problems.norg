* Medium Problems

** ( ) [Number of Islands]{https://leetcode.com/problems/number-of-islands/description/}

   %TOPICS: Depth_First_Search%

*** (x) Approach One (Recursive DFS)

    The idea is simple, iteratively visit each cell in the gird, when a land
    cell ('`1`') is found, recursively sink all the land cells adjacent of this
    land cell by changing their value to '`0`'. Essentially no land cell will
    be visited more than once, hence when the recursive function will return
    all the land cells adjacent to the current cell would have been sunk by
    then. This means only cells that were completely disconnected to other land
    cells would contribute to number of islands.

    @code python
    def numIslands(self, grid: List[List[str]]) -> int:
        m = len(grid)
        n = len(grid[0])
        dirs = [1, 0, -1, 0, 1]

        def sink(i: int, j: int):
            grid[i][j] = "0"

            for k in range(4):
                new_i = dirs[k] + i
                new_j = dirs[k + 1] + j
                if (
                    new_i >= 0
                    and new_j >= 0
                    and new_i < m
                    and new_j < n
                    and grid[new_i][new_j] == "1"
                ):
                    sink(new_i, new_j)
        count = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == "1":
                    sink(i, j)
                    count += 1

        return count
    @end

    *Time Complexity*: The algorithm do not revisit cells that have been sunk,
    hence the overall time complexity will be $O(m \times n)$.
    *Space Complexity*: The worst case space complexity will be $O(m \times n)$
    when the grid will be filled with all '`1`'s, due to the recursion stack.

