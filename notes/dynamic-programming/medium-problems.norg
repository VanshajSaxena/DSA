* ( ) Medium Problems

** ( ) [Longest Common Subsequence]{https://leetcode.com/problems/longest-common-subsequence/description/}

   %TOPICS: Dynamic_Programming(Bottom-up)%

*** (x) Approach One

    This problem can be solved using the bottom-up approach of dynamic
    programming. We can first start with the subproblems and then build up the
    solution to the main problem. A 2D array of dimensions $m + 1 \times n + 1$
    filled with zeros can be used to store the solutions to the subproblems,
    where `m` and `n` are the lengths of the two strings. The extra row and
    column accounts for the empty string, whose score will be 0.

    @code python
    dp: List[List[int]] = [[0] * (len(text2) + 1) for _ in range(len(text1 ) + 1)]

    for i in range(len(text1) - 1, -1, -1):
      for j in range(len(text2) - 1, -1, -1):
        if text1[i] == text2[j]:
          dp[i][j] = 1 + dp[i + 1][j + 1]
        else:
          dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])
    @end

    *Time Complexity*: $O(m \times n)$
    *Space Complexity*: $O(m \times n)$

** ( ) [Longest Palindromic Subsequence]{https://leetcode.com/problems/longest-palindromic-subsequence/description/}

   %TOPICS: Dynamic_Programming(Bottom-up)%

*** ( ) Approach One

    *Time Complexity*:
    *Space Complexity*:


