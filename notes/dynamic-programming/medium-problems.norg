* ( ) Medium Problems

** ( ) [Longest Common Subsequence]{https://leetcode.com/problems/longest-common-subsequence/description/}

   %TOPICS: Dynamic_Programming, Tabulation%

*** (x) Approach One

    This problem can be solved using the bottom-up approach of dynamic
    programming. We can first start with the subproblems and then build up the
    solution to the main problem. A 2D array of dimensions $m + 1 \times n + 1$
    filled with zeros can be used to store the solutions to the subproblems,
    where `m` and `n` are the lengths of the two strings. The extra row and
    column accounts for the empty string, whose score will be 0.

    @code python
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        dp: List[List[int]] = [[0] * (len(text2) + 1) for _ in range(len(text1 ) + 1)]

        for i in range(len(text1) - 1, -1, -1):
            for j in range(len(text2) - 1, -1, -1):
                if text1[i] == text2[j]:
                    dp[i][j] = 1 + dp[i + 1][j + 1]
                else:
                    dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])

        return dp[0][0]
    @end

    *Time Complexity*: $O(m \times n)$
    *Space Complexity*: $O(m \times n)$

** ( ) [Longest Palindromic Subsequence]{https://leetcode.com/problems/longest-palindromic-subsequence/description/}

   %TOPICS: Dynamic_Programming, Memoization, Tabulation%

*** (x) Approach One

    This problem can be solved using the same approach as in [Longest Common
    Subsequence]. If the string and its reverse is supplied to the LCS function
    then it is guranteed that the longest palindromic subsequence will be
    returned.

*** (x) Approach Two (Recursion)

    The problem can be visualized as a decision tree problem where at each
    index (or pair of index) we check if there exists the same characters to
    the left and right of the current index.

    @code python
    def longestPalindromeSubseq(self, s: str) -> int:
        def dfs(i: int, j: int):
            if (i < 0) or (j >= len(s)):
                return 0

            if s[i] == s[j]:
                result = dfs(i - 1, j + 1)
                length = 1 if i == j else 2
                return length + result
            else:
                result = max(dfs(i - 1, j), dfs(i, j + 1))
                return result

        result = 0
        for i in range(len(s)):
            result = max(result, dfs(i, i), dfs(i, i + 1))

        return result
    @end

    *Time Complexity*: This has a time complexity of $O(2^n)$.

*** (+) Approach Three (Memoization)

    The time complexity of the previous approach can be improved by caching the
    results of the subproblems.

    @code python
    def longestPalindromeSubseq(self, s: str) -> int:
        cache = {}
        def dfs(i: int, j: int):
            if (i < 0) or (j >= len(s)):
                return 0
            # return if result exists in cache
            if (i, j) in cache:
                return cache[(i, j)]

            if s[i] == s[j]:
                result = dfs(i - 1, j + 1)
                length = 1 if i == j else 2
                cache[(i, j)] = length + result
                return cache[(i, j)] # cache the result
            else:
                result = max(dfs(i - 1, j), dfs(i, j + 1))
                cache[(i, j)] = result
                return cache[(i, j)] # cache thre resutl

        result = 0
        for i in range(len(s)):
            result = max(result, dfs(i, i), dfs(i, i + 1))

        return result
    @end

    *Time Complexity*: This improves the time complexity form $O(2^n)$ to
    $O(n^2)$.

    The solution above still don't get accepted by LeetCode, maybe due to
    recursion.

*** (!) Approach Four (Tabulation)

    Rather than building the solutions to subproblems top-down, we can build
    them from the bottom and move up.

    @code python
    def longestPalindromeSubseq(self, s: str) -> int:
        dp = [[0] * (len(s) + 1) for _ in range(len(s) + 1)]
        result = 0
        for i in range(len(s)):
            for j in range(len(s) - 1, i - 1, -1):
                if s[i] == s[j]:
                    dp[i][j] = 1 if i == j else 2
                    if i - 1 >= 0:
                        dp[i][j] += dp[i - 1][j + 1]
                else:
                    dp[i][j] = dp[i][j + 1]
                    if i - 1 >= 0:
                        dp[i][j] = max(dp[i][j], dp[i - 1][j])
                result = max(result, dp[i][j])

        for arr in dp:
            print(arr, "\n")
        return result

    # dp array after dry-run
    # [1, 2, 2, 2, 2, 0]
    # [0, 3, 4, 2, 2, 0]
    # [0, 0, 3, 2, 2, 0]
    # [0, 0, 0, 3, 2, 0]
    # [0, 0, 0, 0, 1, 0]
    # [0, 0, 0, 0, 0, 0]
    @end

    *Time Complexity*: The outer loop runs from `i = 0` to `len(s) - 1` and for
    each `i`, the inner loop iterates from `j = len(s) - 1` to `i`.

    In the worst case, there will be: $n(n+1)/2$ iterations, where `n`
    is `len(s)`. Hence the overall time complexity is $O(n^2)$.

    *Space Complexity*: The size of the `dp` array is `len(s) + 1` by `len(s) +
    1`, which requires $O(n^2)$ space.

** ( ) [House Robber]{https://leetcode.com/problems/house-robber/description/}

   %TOPICS: Dynamic_Programming, Memoization, Tabulation%

*** (x) Approach One

    The problem can be visualized just like a decision problem; At each step we
    can rob any house except the house adjacent to the house we are currently
    at. It makes sense to rob any previous house of the same parity to the
    house with relatively more money.

    Example: For houses `[1, 2, 1, 1, 4, 10]`, if we want to rob the last house,
    we may also rob the house at index 3 and index 1, to maximise the robbery.

    We can spawn a recursive function at each index `i + 2 .. len(n) - 1`.

    @code python
    def rob(self, houses: List[int]) -> int:
        n = len(houses)
        def r(idx: int) -> int:
            if idx >= n:
                return 0
            inter_result = 0
            for i in range(idx + 2, n):
                inter_result = max(inter_result, r(i))
            result = inter_result + houses[idx]
            return result
        return max(r(0), r(1))
    @end

    The recurrence relation for the program can be expressed as:

    @math
    \[
    T(\text{idx}) = \sum_{i=\text{idx}+2}^{n-1} T(i) + O(n-\text{idx})
    \]
    \[
    T(\text{idx}) = \sum_{i=\text{idx}+2}^{n-1} T(i) + O(n)
    \]
    @end

    *Time Complexity*: This gives us exponential time complexity of
    approximately $O(2^n)$.
    *Space Complexity*: Due to the for-loop in the recursive function, the
    number of function invocations will be exponential (roughly
    $O(2^n)$), in the worst case. Whereas the number of active calls on
    the stack at any time will be $O(n)$.

*** (x) Approach Two (Memoization)

    @code python
    def rob(self, houses: List[int]) -> int:
        n = len(houses)
        cache = {}

        def r(idx: int) -> int:
            if idx >= n:
                return 0
            if idx in cache:
                return cache[idx]
            inter_result = 0
            for i in range(idx + 2, n):
                inter_result = max(inter_result, r(i))
            result = inter_result + houses[idx]
            cache[idx] = result
            return result

        return max(r(0), r(1))
    @end

    This program iterates from index `idx + 2 .. n - 1` at each recursive
    call.

    *Time Complexity*: Since each index is processed once, and the processing
    of an index takes $O(n)$ time (due to loop), the overall time complexity of
    the program is approximately $O(n^2)$.
    *Space Complexity*: The space complexity is still $O(n)$ due to the `cache`
    and the recursive call stack having $O(n)$ active calls at any time.

*** (x) Approach Three (Optimized Memoization)

    We don't need to iterate over all the indices from `idx + 2` to `n - 1`.
    The problem can be thought of as mainly having two options when calculating
    result for each index; whether to rob or not rob the current house.

    - If we rob the current house, we can not rob the next house, but can rob
      subsequent houses.
    - If we do not rob the current house, we can rob the next house.

    @code python
    def rob(self, houses: List[int]) -> int:
        n = len(houses)
        cache = {}

        def r(idx: int) -> int:
            if idx >= n:
                return 0
            if idx in cache:
                return cache[idx]
            result = max((houses[idx] + r(idx + 2)), r(idx + 1))
            cache[idx] = result
            return result

        return r(0)
    @end

    *Time Complexity*: Due to caching the result for any index is calculated at
    most once, hence the time complexity will be $O(n)$.
    *Space Complexity*: The space complexity will be $O(n)$ due to `cache` and
    the recursive call stack.

