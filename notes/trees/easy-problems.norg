* Easy Problems

** (x) [Convert Sorted Array to Binary Search Tree]{https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/}

   %TOPICS: Binary_Search_Tree%

*** (x) Approach One

    Recursively pick the middle of the array, call it the root of the current
    subtree, this will divide the array in two subarrays. Perform the same
    operation on the subarrays. If the range closes (left surpasses right),
    return null.

    @code python
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        n = len(nums)

        def convert(left: int, right: int) -> Optional[TreeNode]:
            if left > right:
                return None
            mid = (right + left) // 2
            node = TreeNode(nums[mid])

            node.left = convert(left, mid - 1)
            node.right = convert(mid + 1, right)

            return node
        convert(0, n - 1)
    @end

    *Time Complexity*: The function process each element once, hence $O(n)$.
    *Space Complexity*: If we count only the extra space, the space complexity
    is $O(\log{n})$ (the max depth of the recursive call stack). But, if we
    also count the output tree, the overall space complexity will be $O(n)$.

** (x) [Invert Binary Tree]{https://leetcode.com/problems/invert-binary-tree/description/}

   %TOPICS: Binary_Tree%

*** (x) Approach One

    Swap the *references* of the left and the right subtrees recursively for
    each node in the tree.

    @code python
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if root is None:
            return

        root.left, root.right = root.right, root.left

        self.invertTree(root.left)
        self.invertTree(root.right)

        return root
    @end

    *Time Complexity*: $O(n)$
    *Space Complexity*: $O(\log{n})$

** (x) [Maximum Depth of Binary Tree]{https://leetcode.com/problems/maximum-depth-of-binary-tree/description/}

   %TOPICS: Binary_Tree%

*** (x) Approach One

    Recursively call the `depth` function for each subtree of the current tree
    and add 1 to each branch call. Take the max of both the branches and return
    the `maxDepth`.

    @code python
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        def depth(node):
            if node is None:
                return 0

            left = 1 + depth(node.left)
            right = 1 + depth(node.right)

            maxDepth = max(left, right)
            return maxDepth

        return depth(root)
    @end

    *Time Complexity*: This will traverse all the nodes of the binary tree,
    hence $O(n)$.
    *Space Complexity*: The best case time complexity will be
    $O(\log{n})$ when the tree is balanced, whereas the worst case time
    complexity will be $O(n)$ when the tree is skewed.

** (x) [Diameter of Binary Tree]{https://leetcode.com/problems/diameter-of-binary-tree/description/}

   %TOPICS: Binary_Tree%

*** (x) Approach One

    @code python
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        self.max_diameter = 0

        def diameter(node) -> int:
            if not node:
                return 0
            left = diameter(node.left)
            right = diameter(node.right)
            self.max_diameter = max(self.max_diameter, left + right)
            return 1 + max(left, right)

        diameter(root)
        return self.max_diameter
    @end

    *Time Complexity*: $O(n)$
    *Space Complexity*: Best case space complexity will be $O(\log{n})$,
    whereas the worst case time complexity will be $O(n)$.

