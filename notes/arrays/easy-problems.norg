* ( ) Easy Problems

** (x) [Check If Array is Sorted and Rotated]{https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/description/}

   One of the best way to check if an array is sorted is to use bubble
   sort. It has a best case time complexity of $O(n)$.

   .image sorting-algorithms-complexities.png

** (x) [Remove Duplicates from Sorted Array]{https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/}

   To do it in linear time complexity, use two pointers. One pointer takes care
   of the current index to write to, and the other pointer checks for
   duplicates in the array. Whenever a new element is found, the write pointer
   can be incremented, and the new value can be written.

** (x) [Rotate Array]{https://leetcode.com/problems/rotate-array/}

   The trick is in reversing the array in three separate steps. First, reverse
   the entire array. Then, reverse the first $k$ elements. Finally, reverse the
   remaining $n - k$ elements.

** (x) [Move Zeros]{https://leetcode.com/problems/move-zeroes/}

   The trick to minimize the operations is to realize:

   All elements before the slow pointer can be non-zero, And all elements
   between slow pointer and the current can be zeros.

** (x) [Missing Number]{https://leetcode.com/problems/missing-number/description/}

   The most optimal solution is to use the XOR operation. The XOR operator
   has a special quality, when two same numbers are XORed they result in 0.
   This special property can be used to find the missing number.

** (x) [Max Consecutive Ones]{https://leetcode.com/problems/max-consecutive-ones/description/}

   You actually need to have a way to cache the state of the number of ones
   encountered before. This state can be stored in a variable, which needs to
   be incremented whenever a one is encountered, and reset to zero whenever a
   zero is encountered. At each step in the iteration process, when you
   encounter a one a global max state can be updated, which will accumulate the
   maximum number of ones encountered so far.

** (x) [Single Number]{https://leetcode.com/problems/single-number/description/}

   [Missing Number]

** (x) [Two Sum]{https://leetcode.com/problems/two-sum/description/}

   This problem can be solved by using a map. At each iteration step, you query
   the map to check if you have encountered a value that could be used to
   create the two sum with the current iteration value.

** (x) [Sort Colors]{https://leetcode.com/problems/sort-colors/description/}

   Use Dutch National Flag Algorithm, maintaining three pointers: low, mid, high.

   Put low and mid at beginning & high at the end.

   The idea behind the algorithm is to keep all the 0s before the low pointer, all
   the 2s after the high pointer, and all the 1s between the low and high
   pointers. The algorithm moves the mid pointer through the array, comparing
   the value at each position with 1. If the value is 0, the element is swapped
   with the element at the low pointer, and the low and mid pointers are
   incremented. If the value is 2, the element is swapped with the element at
   the high pointer, and the high pointer is decremented. If the value is 1,
   the mid pointer is simply incremented.

** (x) [Majority Element]{https://leetcode.com/problems/majority-element/description/}

   This uses a clever technique, Moore's Voting Algorithm: It is only works if
   there is a clear majority.

   The intuition behind the Moore's Voting Algorithm is based on the fact that if
   there is a majority element in an array, it will always remain in the lead,
   even after encountering other elements.

   So, if for each candidate element, we cancel out its occurrence with other,
   only the majority candidate element will remain.
