* ( ) Easy Problems

** (x) [Check If Array is Sorted and Rotated]{https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/description/}

   One of the best way to check if an array is sorted is to use bubble
   sort. It has a best case time complexity of $O(n)$.

   .image sorting-algorithms-complexities.png

** (x) [Remove Duplicates from Sorted Array]{https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/}

   To do it in linear time complexity, use two pointers. One pointer takes care
   of the current index to write to, and the other pointer checks for
   duplicates in the array. Whenever a new element is found, the write pointer
   can be incremented, and the new value can be written.

** (x) [Rotate Array]{https://leetcode.com/problems/rotate-array/}

   The trick is in reversing the array in three separate steps. First, reverse
   the entire array. Then, reverse the first $k$ elements. Finally, reverse the
   remaining $n - k$ elements.

** (x) [Move Zeros]{https://leetcode.com/problems/move-zeroes/}

   The trick to minimize the operations is to realize:

   All elements before the slow pointer can be non-zero, And all elements
   between slow pointer and the current can be zeros.

** (x) [Missing Number]{https://leetcode.com/problems/missing-number/description/}

   The most optimal solution is to use the XOR operation. The XOR operator
   has a special quality, when two same numbers are XORed they result in 0.
   This special property can be used to find the missing number.

** (x) [Max Consecutive Ones]{https://leetcode.com/problems/max-consecutive-ones/description/}

   You actually need to have a way to cache the state of the number of ones
   encountered before. This state can be stored in a variable, which needs to
   be incremented whenever a one is encountered, and reset to zero whenever a
   zero is encountered. At each step in the iteration process, when you
   encounter a one a global max state can be updated, which will accumulate the
   maximum number of ones encountered so far.

** (x) [Single Number]{https://leetcode.com/problems/single-number/description/}

   [Missing Number]

** (x) [Two Sum]{https://leetcode.com/problems/two-sum/description/}

   This problem can be solved by using a map. At each iteration step, you query
   the map to check if you have encountered a value that could be used to
   create the two sum with the current iteration value.

** (x) [Sort Colors]{https://leetcode.com/problems/sort-colors/description/}

   Use Dutch National Flag Algorithm, maintaining three pointers: low, mid, high.

   Put low and mid at beginning & high at the end.

   The idea behind the algorithm is to keep all the 0s before the low pointer, all
   the 2s after the high pointer, and all the 1s between the low and high
   pointers. The algorithm moves the mid pointer through the array, comparing
   the value at each position with 1. If the value is 0, the element is swapped
   with the element at the low pointer, and the low and mid pointers are
   incremented. If the value is 2, the element is swapped with the element at
   the high pointer, and the high pointer is decremented. If the value is 1,
   the mid pointer is simply incremented.

** (x) [Majority Element]{https://leetcode.com/problems/majority-element/description/}

   This uses a clever technique, Moore's Voting Algorithm: It is only works if
   there is a clear majority.

   The intuition behind the Moore's Voting Algorithm is based on the fact that if
   there is a majority element in an array, it will always remain in the lead,
   even after encountering other elements.

   So, if for each candidate element, we cancel out its occurrence with other,
   only the majority candidate element will remain.

** [Apply Operations to an Array]{https://leetcode.com/problems/apply-operations-to-an-array/description/}

   The question demands to apply a series of operations to an array. This can
   be achieved by creating an auxiliary array of the same length and applying
   the operations in order. First double the element and set the next element
   to zero whenever the condition is met. Next by iterating the array, capture
   any non-zero number to the auxiliary array, by incrementing a
   `non-zero-index` at each step. Finally by iterating the array again, fill
   the remaining elements with zeros to the length of the array.

   This give the overall time and space complexity of $O(n)$ and  $O(1)$
   respectively.

   To optimize the memory used by the auxiliary array, we can modify the array
   in-place. It has some implications:

   > In-place algorithms overwrite the input to save space, but sometimes this
   > can cause problems. Here are a couple of situations where an in-place
     algorithm might not be suitable:

   ~ The algorithm needs to run in a multi-threaded environment without
     exclusive access to the array. Other threads might need to read the array
     as well and may not expect it to be modified.
   ~ Even if there is only a single thread or the algorithm has exclusive
     access to the array while running, the array might need to be reused later
     or by another thread once the lock has been released.

   This can be asked in an interview.

   By maintaining a separate `non-zero-index` variable, we can overwrite the
   array with the current non zero values encountered. And later filling the
   remaining array with zeros. But, this approach still compels at least two
   passes.

   The operations can be applied in a single pass; In this approach when we
   encounter a non zero value we increment our `write-index` variable and swap
   the element at the current index with `write-index` only if our current
   index does not match `write-index` By only incrementing the `write-index`
   when we encounter a non zero value we ensure when we next time meet a non
   zero value the `write-index` will be at a zero value position. Thus we can
   do a swap, which naturally pushes the zero at the end of the array.

   This makes the space complexity to be $O(1)$, as we are not using any extra
   space, but only a few variables.

